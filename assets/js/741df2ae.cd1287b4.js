"use strict";(self.webpackChunkshape_z_docs=self.webpackChunkshape_z_docs||[]).push([[6095],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(6540);const r={},o=t.createContext(r);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(o.Provider,{value:n},e.children)}},9446:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"internals","title":"Internals & Todo","description":"Shape-Z has a manual parser which generates an AST. The AST in turn compiles the code into a recursive byte code VM. The VM is about 15% slower than native rust code.","source":"@site/docs/internals.md","sourceDirName":".","slug":"/internals","permalink":"/docs/internals","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Internals & Todo"},"sidebar":"tutorialSidebar","previous":{"title":"Patterns","permalink":"/docs/patters"}}');var r=s(4848),o=s(8453);const a={sidebar_position:6,title:"Internals & Todo"},i=void 0,c={},l=[];function h(e){const n={code:"code",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Shape-Z"})," has a manual parser which generates an AST. The AST in turn compiles the code into a recursive byte code VM. The VM is about 15% slower than native rust code."]}),"\n",(0,r.jsxs)(n.p,{children:["This is partly thanks to the fact that we only have one internal data type: ",(0,r.jsx)(n.code,{children:"vec3"}),", so each operation (like a ",(0,r.jsx)(n.code,{children:"cos"}),") is always executed on all 3 components. Which is fine on native as it is SIMD anyway, but it is one of the reasons the WASM code on this website is slower (because no SIMD support for WASM yet)."]}),"\n",(0,r.jsx)(n.p,{children:"The VM compiles the voxels into a voxel grid which are path traced via an DDA algorithm."}),"\n",(0,r.jsx)(n.p,{children:"I choose a CPU architecture over a GPU one because of"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursive nature of the language."}),"\n",(0,r.jsx)(n.li,{children:"The more flexible access to large chunks of memory, in my tests I rendered 30-40 gigabyte of voxels without problems."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"The todo list for Shape-Z is long."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Materials can be imported and re-used. However Objects (shape based reusable modules to share furniture and other content)."}),"\n",(0,r.jsx)(n.li,{children:"I am working on concepts for organic forms (trees, bushes, grass, vines)."}),"\n",(0,r.jsx)(n.li,{children:"More 3D mesh export formats beside .OBJ and support for textures (for patterns etc)."}),"\n",(0,r.jsx)(n.li,{children:"More SDF helpers (the list is nearly endless here)."}),"\n",(0,r.jsx)(n.li,{children:"A GitHub based treasury for materials and modules to build up a DB of content which Shape-Z can freely access."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"And of course a lot more shapes, patterns, distance volumes etc."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);